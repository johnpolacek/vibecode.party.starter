---
description: 
globs: 
alwaysApply: false
---
# Firebase Implementation Guide

## Setup & Configuration

### Firebase Admin Initialization
Firebase Admin should be initialized as a singleton in `lib/firebase/admin.ts`:

```typescript
import { initializeApp, getApps, cert } from 'firebase-admin/app';
import { getFirestore, Firestore } from 'firebase-admin/firestore';

let _firestoreInstance: Firestore | undefined;

function initializeFirebaseAdmin() {
  // Only initialize if no apps exist
  if (getApps().length === 0) {
    // Use demo config for development and test environments
    if (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test') {
      initializeApp({
        projectId: 'demo-project'
      });
    } else {
      if (!process.env.FIREBASE_PROJECT_ID || !process.env.FIREBASE_PRIVATE_KEY || !process.env.FIREBASE_CLIENT_EMAIL) {
        throw new Error('Firebase Admin credentials are required in production');
      }
      
      initializeApp({
        credential: cert({
          projectId: process.env.FIREBASE_PROJECT_ID,
          clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
          privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
        }),
      });
    }
  }
}

function getFirestoreInstance(): Firestore {
  if (!_firestoreInstance) {
    try {
      initializeFirebaseAdmin();
      _firestoreInstance = getFirestore();
      
      // Configure emulator for development or test
      if (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test') {
        _firestoreInstance.settings({
          host: '127.0.0.1:8080',
          ssl: false,
          ignoreUndefinedProperties: true
        });
      }
    } catch (error) {
      console.error('Error initializing Firestore:', error);
      throw error;
    }
  }
  
  return _firestoreInstance;
}

// Export a singleton instance
export const db = getFirestoreInstance();
```

### Environment Setup

1. **Development**
   ```env
   NODE_ENV=development
   ```
   - Uses Firebase emulator
   - No real credentials needed

2. **Production**
   ```env
   FIREBASE_PROJECT_ID=your-project-id
   FIREBASE_CLIENT_EMAIL=your-client-email
   FIREBASE_PRIVATE_KEY=your-private-key
   ```

### Firebase CLI Setup

1. **Installation**
   ```bash
   pnpm add -g firebase-tools
   ```

2. **Login**
   ```bash
   firebase login
   ```

3. **Initialize Project**
   ```bash
   firebase init
   ```
   Select:
   - Firestore
   - Emulators (select Firestore emulator)

4. **Start Emulators**
   ```bash
   firebase emulators:start
   ```

## Implementation Patterns

### Service Layer Pattern

Create service classes for each collection to encapsulate Firebase operations:

```typescript
// lib/services/idea-service.ts
import { db } from '../firebase/admin'
import { FieldValue, QueryDocumentSnapshot } from 'firebase-admin/firestore'

export interface Idea {
  id: string
  title: string
  description: string
  // ... other fields
}

export class IdeaService {
  private collection = db.collection('ideas')

  async createIdea(input: CreateIdeaInput, userId: string): Promise<Idea> {
    const docRef = this.collection.doc()
    const idea = {
      ...input,
      submitterId: userId,
      createdAt: FieldValue.serverTimestamp()
    }
    await docRef.set(idea)
    return { id: docRef.id, ...idea }
  }

  // ... other methods
}
```

### Server Actions Pattern

Server actions must be marked with 'use server' directive and handle Clerk authentication:

```typescript
// app/_actions/ideas.ts
'use server'

import { auth } from "@clerk/nextjs/server"
import { IdeaService, CreateIdeaInput } from "@/lib/services/idea-service"

const ideaService = new IdeaService()

export async function createIdea(input: CreateIdeaInput) {
  const { userId } = await auth()
  if (!userId) throw new Error("Unauthorized")
  return ideaService.createIdea(input, userId)
}

export async function listIdeas(limit?: number) {
  return ideaService.listIdeas(limit)
}
```

### Client Component Pattern

When using Firebase operations in client components, import server actions as a module:

```typescript
// components/some-component.tsx
"use client"

import * as actions from "@/app/_actions/ideas"

export function SomeComponent() {
  const [ideas, setIdeas] = useState<Idea[]>([])

  useEffect(() => {
    async function loadIdeas() {
      try {
        const loadedIdeas = await actions.listIdeas()
        setIdeas(loadedIdeas)
      } catch (err) {
        console.error('Error:', err)
      }
    }
    loadIdeas()
  }, [])
}
```

## Best Practices

1. **Server vs Client**
   - Keep all Firebase operations server-side
   - Use server actions for client-server communication
   - Import server actions as a module in client components

2. **Authentication**
   - Use Clerk's `auth()` in server actions
   - Handle authentication errors appropriately
   - Include proper TypeScript types

3. **Error Handling**
   - Use try/catch blocks in server actions
   - Return appropriate error messages
   - Log errors server-side

4. **Development**
   - Use Firebase emulator in development
   - Don't mock Firebase in development
   - Use proper environment variables

5. **TypeScript**
   - Use proper types for documents and collections
   - Type server action parameters and returns
   - Use QueryDocumentSnapshot for mapping results

## Common Patterns

### Fetching Data
```typescript
// Server Action
'use server'
export async function getData(id: string) {
  const { userId } = await auth()
  if (!userId) throw new Error("Unauthorized")
  return service.getData(id)
}

// Client Usage
import * as actions from "@/app/_actions/data"
const data = await actions.getData(id)
```

### Creating Documents
```typescript
// Server Action
'use server'
export async function createDoc(input: InputType) {
  const { userId } = await auth()
  if (!userId) throw new Error("Unauthorized")
  return service.create({ ...input, userId })
}

// Client Usage
import * as actions from "@/app/_actions/docs"
await actions.createDoc(input)
```

### Updating Documents
```typescript
// Server Action
'use server'
export async function updateDoc(id: string, input: InputType) {
  const { userId } = await auth()
  if (!userId) throw new Error("Unauthorized")
  
  const doc = await service.get(id)
  if (doc.userId !== userId) throw new Error("Unauthorized")
  
  return service.update(id, input)
}
```

### Batch Operations
```typescript
// Service Method
async batchUpdate(updates: BatchUpdate[]) {
  const batch = db.batch()
  updates.forEach(update => {
    const ref = this.collection.doc(update.id)
    batch.update(ref, update.data)
  })
  await batch.commit()
}
```

### Transactions
```typescript
// Service Method
async transferPoints(fromId: string, toId: string, amount: number) {
  await db.runTransaction(async (t) => {
    const fromDoc = await t.get(this.collection.doc(fromId))
    const toDoc = await t.get(this.collection.doc(toId))
    
    if (!fromDoc.exists || !toDoc.exists) throw new Error("Document not found")
    
    const fromPoints = fromDoc.data()?.points || 0
    if (fromPoints < amount) throw new Error("Insufficient points")
    
    t.update(fromDoc.ref, { points: fromPoints - amount })
    t.update(toDoc.ref, { points: (toDoc.data()?.points || 0) + amount })
  })
}
```
